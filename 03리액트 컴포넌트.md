# 3. 리액트 컴포넌트

## 3-1. 컴포넌트를 표현하는 JSX

<aside>
✅ **JSX(JavaScript XML)**

- 자바스크립트에 XML을 추가한 확장형 문법
- 하나의 파일에 자바스크립트와 HTML을 동시에 작성할 수 있어 편리함
</aside>

### JSX 사용해보기

```jsx
import React from 'react';

class App extends React.Component{
    render() {
        return (
            // JSX 양식
            <div>
                <img src="http://www.easypub.co.kr/images/logo_footer.png" />
                <div>안녕하세요</div>
            </div>
        );
    }
}
export defalut App;
```

위 코드의 JSX

- return() 함수 내에 HTML을 사용
- img 엘리먼트에 />에 사용

render() 함수의 반환값은 거의 HTML과 비슷하지만 마침 표시 />가 있다는 차이가 있음

⇒ JSX는 XML 마크업 규칙을 따름 ( <와 /> 짝이 맞지 않으면 리액트 엔진이 JSX 분석 시 오류 발생)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc3e8fc3-8b7b-4122-9f0c-ee0d11b2efbb/Untitled.png)

- creat-react-app은 오류 발생 시 웹 브라우저에서 바로 볼 수 있음
  ![syntax error](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2b460183-25bb-44d3-9a2e-b2f4ec35f342/Untitled.png)
  syntax error
- 오류 해결하면 정상적으로 브라우저에서 확인 가능
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef771799-e658-4160-b732-cc7faf9a09b3/Untitled.png)

### JSX와 기존 개발 방법의 차이점

1. App 컴포넌트를 사용하지 않고 화면 구성해 보기

index.js - npm start(yarn start) 명령어로 리액트 서버 구동 시 최초로 실행됨

```jsx
// 필수 리액트 구동 모듈들
import React from "react";
import ReactDOM from "react-dom/client";
// 초기 화면을 구성하는 사용자 코드
import "./index.css";
import App from "./App";
import * as serviceWorker from "./serviceWorker";

// 리액트 엔진이 화면을 출력하는 코드
// id가 root인 엘리먼트에 컴포넌트를 출력
ReactDOM.render(<App />, document.getElementById("root"));

// 서비스 워커 구동 코드로 오프라인 모드로 작동하는 데 도움이 되는 모듈
// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
serviceWorker.unregister();
```

1. App 컴포넌트 미사용 시 코드 수정

```jsx
var img = document.createElement("img");
img.setAttribute("src", "http://www.easyspub.co.kr/images/logo_footer.png");
var divEl = document.createElement("div");
divEl.innerText = "안녕하세요";
var welcomeEl = document.createElement("div");
welcomeEl.append(img);
welcomeEl.append(divEl);

var root = document.getElementById("root");
root.append(welcomeEl);
```

브라우저는 같은 값을 보여 주지만, 코드가 복잡해져 비효율적임

1. 실습에 불필요한 코드까지 정리

```jsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root"));
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31d4a2f0-821b-49b1-b9d4-96ddebb21241/Untitled.png)

### JSX 작동 원리

```jsx
...
return (
  // JSX가 자바스크립트로 변환된 것
  React.createElement(
    "div",
    null,
    React.createElement("img", {
      src: "http://easyspub.co.kr/images/logo_footer.png"
    }),
    React.createElement(
      "div",
      null,
      "안녕하세요"
    )
  )
);
```

리액트 엔진은 JSX의 XML 구조를 분석하여 자바스크립트 함수 코드로 변환

React.createElement() 함수는 리액트 엔진에 포함되어 있고, 기존 자바스크립트의 document.createElement() 함수를 사용하여 객체 모델을 생성함

리액트를 사용하면 이 같은 과정 없이 JSX로 화면을 빠르게 구성할 수 있음 ⇒ “선언형 화면(Declarative View)”

JSX는 개발자가 화면 구성에만 집중할 수 있도록 도움

## 3-2. 컴포넌트와 구성 요소

> **컴포넌트는 리액트의 꽃이라 불릴 정도로 리액트에서 가장 중요한 요소**

### 컴포넌트의 개념

기존의 웹 프레임워크

- MVC 방식 : 정보Model, 화면View, 구동 코드Controller를 분리하여 관리
- 장점 : 코드 관리를 효율적으로 할 수 있음
- 단점 : MVC 각 요소의 의존성이 높아 재활용이 어려움

→ 웹 사이트의 요소가 비슷하고 반복적인 점을 착안하여 컴포넌트가 등장하게 됨

컴포넌트

- MVC의 뷰를 독립적으로 구성하여 재사용 가능
- 컴포넌트를 통해 새로운 컴포넌트를 쉽게 만들 수 있음

### 컴포넌트 추가하고 화면으로 띄워보기

1. TodaysPlan 컴포넌트 만들기
   TodaysPlan.jsx

```jsx
import React from "react";

class TodaysPlan extends React.Component {
  render() {
    return <div className="message-container">놀러가자</div>;
  }
}

export default TodaysPlan;
```

- 컴포넌트 이름의 첫 번째 글자는 반드시 대문자여야 함

1. App 컴포넌트에 TodaysPlan 컴포넌트 추가하기

작성한 컴포넌트 App 컴포넌트에 추가

컴포넌트를 마크업 형식으로 추가하므로 첫 글자가 대문자여야 함!

```jsx
import React from "react";
// 작성된 컴포넌트를 불러들임
import TodaysPlan from "./03/TodaysPlan";

class App extends React.Component {
  render() {
    return (
      <div className="body">
        <TodaysPlan />
      </div>
    );
  }
}
export default App;
```

1. TodaysPlan 컴포넌트 출력하기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d84334cb-466f-4517-9d2c-130b18823aae/Untitled.png)

<aside>
💡 Import문에서 파일 이름 확장자가 생략된 이유

create-react-app은 js / jsx 확장자를 생략해도 해당 파일을 자동으로 찾을 수 있게 설정됨

“웹팩 코드 검색 확장자(webpack module resolution)” 기능

웹팩은 임포트된 파일을 분석하여 하나의 자바스크립트 파일 생성할 때 파일 위치를 검색함(이 때 확장자 기능 참조)

</aside>

### 컴포넌트 구성 요소 미리 살펴보기

데이터 구성요소

- 프로퍼티 : 상위 컴포넌트에서 하위 컴포넌트로 전달되는 읽기 전용 데이터
- state : 컴포넌트의 상태를 저장하고 변경할 수 있는 데이터
- 컨텍스트 : 부모 컴포넌트에서 생성하여 모든 자식 컴포넌트에 전달하는 데이터

## 3-3. 컴포넌트에 데이터를 전달하는 프로퍼티

### 프로퍼티 기초 알아보기

App 컴포넌트에서 프로퍼티를 MyComponent 컴포넌트에 전달한 예제

속성(attribute) 형태로 전달되는 값을 프로퍼티라고 일컫는다

```jsx
class App extends React.Component {
  render() {
    return (
      <div className="body">
        <MyComponent name="message" />
      </div>
    );
  }
}
```

MyComponent 컴포넌트에서는 name 이라는 이름의 프로퍼티로 전달받은 “message”라는 문자열값을 render() 함수에서 참조할 수 있음

render() 함수에서 this.props.name 으로 프로퍼티 값을 참조하고 있음

```jsx
class App extends React.Component {
  render() {
    const name = this.props.name;
    return <span>{name}</span>;
  }
}
```

프로퍼티는 상위 컴포넌트→하위 컴포넌트로 전달됨

App 컴포넌트가 MyComponent를 포함하고 있으며 프로퍼티는 App → MyComponent 방향으로 전달됨 [단방향으로 데이터가 흐른다]

### 프로퍼티의 다양한 사용 방법 알아보기

프로퍼티에서는 자바스크립트의 모든 자료형 사용 가능

자료형은 미리 선언해주는 것이 좋음

- 리액트 엔진이 프로퍼티로 전달하는 값의 변화를 효율적으로 감지
- 지정되지 않은 자료형을 프로퍼티에 전달하려고 할 때 경고 메세지로 알려줌(버그 예방)

1. **문자열형 프로퍼티 사용하기**

: 리액트에서 제공하는 prop-types 이용

```jsx
import React from "react";
// 1. prop-types 라이브러리를 PropTypes라는 이름으로 임포트
import PropTypes from "prop-types";

class PropsComponent extends React.Component {
  render() {
    // 2. name 프로퍼티로 받은 문자열 출력
    return <div className="message-container">{this.props.name}</div>;
  }
}

// 자료형을 선언하는 예제
PropsComponent.propTypes = {
  // 3. PropsComponent의 propTypes라는 특수 변수(prop-types 라이브러리 임포트 이름과 다름)를 사용하여 프로퍼티의 자료형 정의
  // 4. 프로퍼티의 자료형을 객체 형태로 지정하여 PropsComponent.propTypes에 저장
  name: PropTypes.string,
};

export default PropsComponent;
```

```jsx
import React from "react";
import PropsComponent from "./03/PropsComponent";

class App extends React.Component {
  render() {
    return <PropComponent name="두잇 리액트" />;
  }
}
export default App;
```

```jsx
import React from "react";
import PropComponent from "./03/propsComponent";

class App extends React.Component {
  render() {
    return <PropComponent name="두잇 리액트" />;
  }
}
export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/04bca4ac-0ef8-42f9-aa71-9e0c2be10a88/Untitled.png)

PropComponent 컴포넌트의 프로퍼티로 전달한 문자열이 출력됨

1. **다양한 프로퍼티 사용하기**

문자열 전달 : “ “ 사용

숫자형/불리언 전달 : 큰따옴표 사용 불가

문자열 이외의 값은 중괄호{} 사용

```jsx
import React from "react";
import PropTypes from "prop-types";

class ChildComponent extends React.Component {
  render() {
    const {
      // 객체 구조 분해 할당식을 사용하여 프로퍼티에 전달된 값들을 render() 함수 내의 지역 변수로 재 정의
      boolValue,
      numValue,
      arrayValue,
      objValue,
      nodeValue,
      funcValue,
    } = this.props;

    return (
      <div>
        <span>불리언값: {boolValue}</span>
        <span>숫자값: {numValue}</span>
        <span>배열값: {arrayValue}</span>
        <span>객체값: {String(objValue)}</span>
        <span>노드값: {nodeValue}</span>
        <span>함수값: {String(funcValue)}</span>
      </div>
    );
  }
}
ChildComponent.propTypes = {
  // 객체 형태로 프로퍼티의 자료형을 정의
  boolValue: PropTypes.bool,
  numValue: PropTypes.number,
  arrayValue: PropTypes.arrayOf(PropTypes.number),
  objValue: PropTypes.object,
  nodeValue: PropTypes.node,
  funcValue: PropTypes.func,
};

export default ChildComponent;
```

객체 구조 분해 할당식으로 프로퍼티에 전달된 값을 함수 내 지역 변수로 재정의하면,

this.props.boolValue에서 boolValue와 같이 this.props를 제외하는 방법으로 간단하게 프로퍼티에 접근 가능

새로운 컴포넌트를 만들었으니 App 컴포넌트를 수정해 확인함

```jsx
import React from "react";
import ChildComponent from "./03/ChildComponent";

class App extends React.Component {
  render() {
    return (
      // 수정
      <ChildComponent
        //1.불리언값 전달
        boolValue={true}
        //2.숫자 전달
        numValue={1}
        //3.배열 전달
        arrayValue={[1, 2, 3]}
        //4.객체 전달
        objValue={{ name: "제목", age: 30 }}
        //5.노드 전달
        nodeValue={<h1>노드</h1>}
        //6.함수 객체 전달
        funcValue={() => {
          console.log("메시지");
        }}
      />
    );
  }
}

export default App;
```

arrayValue={[1,2,3]} 처럼 두 개의 중괄호를 사용하는 이유는 개발자 간의 실수를 줄이기 위하여 변수를 객체에 담아 전달하는 방식 선호

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/269383ec-4b25-44b4-af09-8a0308a251f5/Untitled.png)

```jsx
import React from "react";
import ChildComponent from "./03/ChildComponent";

class App extends React.Component {
  render() {
    const array = [1, 2, 3];
    const obj = { name: "제목", age: 30 };
    const node = <h1>노드</h1>;
    const func = () => {
      console.log("메시지");
    };
    return (
      // 수정
      <ChildComponent
        //1.불리언값 전달
        boolValue={true}
        //2.숫자 전달
        numValue={1}
        //3.배열 전달
        arrayValue={array}
        //4.객체 전달
        objValue={obj}
        //5.노드 전달
        nodeValue={node}
        //6.함수 객체 전달
        funcValue={func}
      />
    );
  }
}

export default App;
```

배열, 객체, 노드, 함수를 변수에 담아 전달한 것

1. **불리언 프로퍼티 사용하기**

불리언 : true 또는 false만 정의할 수 있는 특수한 자료형

문자열 외 값은 중괄호로 감싸 전달해야 하지만 불리언은 특별한 방법으로도 전달할 수 있음

true

- 프로퍼티 이름 선언 : <ChildComponent boolVaule />

false

- 이름 생략 : <ChildComponent />

```jsx
import React from "react";

class BooleanComponent extends React.Component {
  render() {
    // 불리언 타입을 조건문에 적용한 예제
    const message = this.props.bored
      ? "놀러 가자"
      : "하던 일 열심히 마무리하기";
    return <div className="message-container">{message}</div>;
  }
}

export default BooleanComponent;
```

```jsx
import React from "react";
import BooleanComponent from "./03/BooleanComponent";

class App extends React.Component {
  render() {
    return (
      <div>
        <div>
          <b>지루할 때:</b>
          <BooleanComponent bored />
        </div>
        <div>
          <b>즐거울 때:</b>
          <BooleanComponent />
        </div>
      </div>
    );
  }
}

export default App;
```

![브라우저](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c739a8d8-5821-48ea-b396-ef7aaf7f2b64/Untitled.png)

브라우저

> 프로퍼티의 이름만 전달한 경우 true, 프로퍼티 이름을 전달하지 않은 경우 false에 해당하는 값이 출력됨
> 실무에서 사용되는 빈도가 높음

1. **객체형 프로퍼티 사용하기**

```jsx
import React from "react";
import PropTypes from "prop-types";

class ChildComponent2 extends React.Component {
  render() {
    const { objValue } = this.props;

    return (
      <div>
        <div>객체값: {String(Object.entries(objValue))}</div>
      </div>
    );
  }
}
ChildComponent2.propTypes = {
  // 객체 프로퍼티
  objValue: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number,
  }),
};

export default ChildComponent2;
```

내장함수 String()과 Object.entries()를 사용하여 객체를 문자열로 변환하여 출력

객체 프로퍼티의 자료형은 PropTypes의 shape를 사용하여 정의

PropTypes.shape로 객체 프로퍼티를 정의하면 객체 목록을 한눈에 확인할 수 있어 편리함

1. **필수 프로퍼티 사용하기**

```jsx
import React from "react";
import PropTypes from "prop-types";

class ChildComponent2 extends React.Component {
  render() {
    const { objValue, requiredStringValue } = this.props;

    return (
      <div>
        <div>객체값: {String(Object.entries(objValue))}</div>
        <div>필수값: {requiredStringValue}</div>
      </div>
    );
  }
}
ChildComponent2.propTypes = {
  // 객체 프로퍼티
  objValue: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number,
  }),
  // 필수 프로퍼티
  requiredStringValue: PropTypes.string.isRequired,
};

export default ChildComponent2;
```

PropTypes에 정의된 변수(string, object, bool, ...) 안의 특수 변수 isRequired를 이용하여 requiredStringValue를 필수 프로퍼티로 지정

```jsx
import React from "react";
import ChildComponent2 from "./03/ChildComponent2";

class App extends React.Component {
  render() {
    return (
      <div>
        <ChildComponent2 objValue={{ age: "20살" }} />
      </div>
    );
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0f6b4362-3a4e-4c80-8429-ad7c9b509832/Untitled.png)

콘솔 오류

- age에 문자열을 대입

- 필수 프로퍼티로 지정한 requiredStringValue에 값이 전달되지 않았음

코드 수정

```jsx
import React from "react";
import ChildComponent2 from "./03/ChildComponent2";

class App extends React.Component {
  render() {
    return (
      <div>
        <ChildComponent2 objValue={{ age: 20 }} requiredStringValue="문자" />
      </div>
    );
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c46ecad-7f0c-4bc3-8a3e-05f96e86dcc1/Untitled.png)

1. **프로퍼티에 기본값 지정하기**

기본값을 저장할 컴포넌트의 defaultProps 값을 이용하면 됨

```jsx
import React from "react";
import PropTypes from "prop-types";

class DefaultPropsComponent extends React.Component {
  render() {
    let message1 = "";
    if (this.props.boolValue === false) {
      message1 = "boolValue 기본값이 false 입니다.";
    }
    let message2 = "";
    if (this.props.boolValueWithoutDefault === false) {
      message2 = "boolValueWithoutDefault 기본값이 false입니다.";
    }
    return (
      <div className="message-container">
        {message1}
        {message2}
      </div>
    );
  }
}

DefaultPropsComponent.propTypes = {
  boolValue: PropTypes.bool,
  boolValueWithoutDefault: PropTypes.bool,
};

// 기본값을 선언하는 예제(특수 변수를 사용하여)
DefaultPropsComponent.defaultProps = {
  boolValue: false,
};

export default DefaultPropsComponent;
```

- 코드
  특수변수를 사용하여 프로퍼티의 기본값을 정의
  불리언 프로퍼티 2개 선언하고 하나의 프로퍼티에만 기본값을 지정
  그다음 두 조건문에서 ===로 비교
  boolValue에만 false가 기본값이라 message1만 출력됨

App 컴포넌트 수정

```jsx
import React from "react";
import DefaultPropsComponent from "./03/DefaultPropsComponent";

class App extends React.Component {
  render() {
    return (
      <div>
        <DefaultPropsComponent />
      </div>
    );
  }
}

export default App;
```

![브라우저](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9115a840-3b6d-47f6-917e-6203183f086b/Untitled.png)

브라우저

1. **자식 프로퍼티 사용하기**

```jsx
<div>
  <button>버튼</button>
</div>
```

위와 같이 중간에 노드를 배치하는 표현식도 JSX에서 표현 가능함

JSX에서는 컴포넌트 하위에 배치한 노드(또는 컴포넌트)를 하위 컴포넌트에서 프로퍼티로 접근할 수 있게 해줌

App 컴포넌트에 포함시킨 ChildProperty 컴포넌트 하위에 자식 노드를 배치한 경우

```jsx
import React from "react";
import ChildProperty from "./03/ChildProperty";

class App extends React.Component {
  render() {
    return (
      <div>
        <ChildProperty>
          <div>
            <span>자식 노드</span>
          </div>
        </ChildProperty>
      </div>
    );
  }
}

export default App;
```

ChildProperty 컴포넌트에서는 {this.props.children}과 같은 방법으로 <div><span>자식 노드</span></div>를 쉽게 받을 수 있음

```jsx
import React, { Component } from "react";
import PropTypes from "prop-types";

class ChildProperty extends Component {
  render() {
    return <div>{this.props.children}</div>;
  }
}
ChildProperty.propTypes = {
  children: PropTypes.node,
};
export default ChildProperty;
```

별도의 프로퍼티를 통해 자식 노드를 전달할 수도 있지만 위 코드가 훨씬 간편함

## 3-4. 컴포넌트 상태 관리하기

프로퍼티의 특징 : 컴포넌트 내부에서 값을 바꿀 수 없다

값을 바꿔야 하는 경우에는? → state를 사용 (state:상태)

### state로 상태 관리하기

state

- 값을 저장하거나 변경할 수 있는 객체
- 버튼을 클릭하거나 값을 변경하는 등의 이벤트와 함께 사용됨

🔽예제 <setTimeout() 함수를 통해 4초 후 state에 저장되어 있는 값을 변경하기>

```jsx
import React from "react";

class StateExample extends React.Component {
  constructor(props) {
    super(props);
    // state 정의
    this.state = {
      //1. 컴포넌트에서 관리하려는 변수 state 초깃값을 this.state에 객체 형태로 정의
      loading: true,
      formData: "no data",
    };
    // 이후 콜백 함수를 다룰 때 bind(this) 추가 학습 예정
    // 2. 함수로 넘어갈 this는 반드시 생성자에서 bind()로 묶어주어야 함 (3-9에서 학습 예정)
    this.handleData = this.handleData.bind(this);
    // 3. setTimeout() 함수를 사용하여 4초 후에 handleData() 함수를 호출
    setTimeout(this.handleData, 4000);
  }
  handleData() {
    const data = "new data";
    // 4. 컴포넌트 특수 변수 this.state를 사용하여 state값에 접근
    const { formData } = this.state;
    //state 변경
    this.setState({
      // 5. 컴포넌트의 내장 함수 this.setState()를 사용하여 state값을 변경
      loading: false,
      formData: data + formData,
    });
    // this.state.loading은 현재 true
    console.log("loading값", this.state.loading);
    // 이후 호출될 render() 함수에서의 this.state.loading은 false
  }
  render() {
    return (
      <div>
        {/*state 데이터는 this.state로 접근 가능. */}
        <span>로딩중: {String(this.state.loading)}</span>
        <span>결과: {this.state.formData}</span>
      </div>
    );
  }
}

export default StateExample;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/39f8fd33-763c-4ae8-9f6c-758df07d1ee0/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b21d2b7b-716c-47bf-b398-c6a42aaca82e/Untitled.png)

<aside>
💡 **constructor() 생성자**

- 메서드를 바인딩하거나 state를 초기화하는 작업이 없다면, 해당 React 컴포넌트에는 생성자를 구현하지 않아도 됨
- 생성자의 목적
  1. this.state에 객체를 할당하여 지역 state를 초기화
  2. 인스턴스에 이벤트 처리 메서드를 바인딩
- constructor() 내부에서 setState()를 호출하면 안 됨
- this.state를 할당할 수 있는 유일한 생성자 (나머지 메서드는 this.setState())
</aside>

프로퍼티에서 단순히 값을 읽어 화면에 출력한 것과 비교할 때, state의 유용함이 더 잘 느껴짐

<aside>
💡 **state를 사용할 때 주의할 점**

1. 생성자(constructor)에서 반드시 초기화 해야 함
   - 마땅한 초깃값이 없다면 빈 객체라도 넣어야 함 this.state = {};
2. state값을 변경할 때는 setState() 함수(상태 관리 함수)를 반드시 사용해야 함
   - state값은 setState() 함수로 변경
     - 직접 변경하면 안 되는 이유 : render() 함수로 화면을 그려주는 시점은 리액트 엔진이 결정 [=직접 변경해도 render() 함수는 새로 호출되지 않음]
     - setState() 함수는 컴포넌트 생명주기와 깊이 연관되어 있음
3. setState() 함수는 비동기로 처리되며, setState() 코드 이후로 연결된 함수들의 실행이 완료된 시점에 화면 동기화 과정을 거침 - setState() 함수의 인자로 함수를 전달하면 이전 state값을 쉽게 읽을 수 있음
</aside>

🔽 일반 함수와 화살표 함수를 setState() 함수의 인자로 전달하여 state 값을 변경

```jsx
// 일반 함수를 사용한 예
handleData(data) {
    this.setState(function(prevState)) {
        const newState = {
            loading: false,
            formData: data + prevState.formData,
        };
        return newState;
    }
}

// 화살표 함수를 사용한 예
handleData(data) {
    this.setState(prevState =>({
        loading: false,
        formData: data + prevState.formData
    }));
}
```

### 클래스 인스턴스 변수와 forceUpdate() 함수로 state 관리하기

setState()는 리액트 엔진이 state의 변경과 화면 동기화 과정을 처리해야 하기 때문에 사용함

그러나,

출력 검증 작업 없이 함수가 호출될 때마다 새롭게 화면을 출력하고 싶다면 클래스 인스턴스 변수와 화면을 강제로 출력해주는 forceUpdate() 함수를 사용하면 됨

```jsx
import React from "react";

class ForceUpdateExample extends React.Component {
  constructor(props) {
    super(props);
    // state 정의
    // 1. 클래스 변수로 초깃값을 정의
    this.loading = true;
    // 2. 클래스 변수로 초깃값을 정의
    this.formData = "no data";
    // 이후 콜백 함수를 다룰 때 bind를 선언하는 부분에 대해 다룸
    this.handleData = this.handleData.bind(this);
    // 4초 후에 handleData를 호출
    setTimeout(this.handleData, 4000);
  }
  handleData() {
    const data = "new data";
    // state 변경
    // 3. 내부 state 변경
    this.loading = false;
    // 4. 내부 state 변경
    this.formData = data + this.formData;
    // 5. 컴포넌트 내장 함수 forceUpdate()를 호출하여 강제로 화면을 새로고침함
    this.forceUpdate();
  }
  render() {
    return (
      <div>
        {/* state 데이터는 this.state로 접근 가능 */}
        <span>로딩중: {String(this.loading)}</span> <br />
        <span>결과: {this.formData}</span>
      </div>
    );
  }
}

export default ForceUpdateExample;
```

```jsx
import React from "react";
import ForceUpdateExample from "./03/ForceUpdateExample";

class App extends React.Component {
  render() {
    return (
      <div>
        <ForceUpdateExample />
      </div>
    );
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ee932ba-fa15-4218-b77f-e7a478602da0/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36826034-7f46-40cf-84c1-90cd85dbe022/Untitled.png)

🚫이 방법은 리액트 성능에 제약이 있으므로 매번 새롭게 화면을 출력해야 되는 경우가 아니라면 가급적 사용하지 않기를 권장

- 실습 : 버튼을 누를 때 숫자가 증가하는 카운터 컴포넌트
  ```jsx
  class Counter extends React.Component {
      constructor(props) {
          super(props);
          // state 정의
          **this.state = { count:0 };**
          this.increaseCount = this.increaseCount.bind(this);
      }
      increaseCount(){
          // state 변경
          **this.setState(count=>{count:count+1});**
      }
      render() {
          return (
              <div>
                  <span>카운트: {this.state.count}</span>
                  <button onClick={this.increaseCount}>카운트 증가</button>
              </div>
          );
      }
  }
  ```

## 3-5. 컴포넌트의 생명주기

컴포넌트의 생성부터 소멸까지의 과정

컴포넌트는 생명주기마다 함수를 가지고 있고 이 함수를 이용해 특정 시점에 원하는 동작을 하도록 만들 수 있음

### 생명주기 함수 살펴보기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d88330e8-2423-45e9-b178-9b32c22fd510/Untitled.png)

render() 함수를 포함하여 총 8종이 있음

리액트 엔진에서 자동으로 호출 (개발자가 마음대로 호출 불가)

**컴포넌트 생성 과정**
: 생성~생성완료

1. constructor(props) 함수

- 맨 처음에 생성될 때 한 번만 호출
- 상태(state 또는 객체 변수) 선언 시 사용
- 항상 super() 함수를 가장 위에 호출해야 함 : super() 함수에는 프로퍼티와 생명 주기 상태 등을 초기화하는 중요한 과정을 포함하고 있기 때문

```jsx
...
constructor(props) {
		super(props);
		// 이후에 추가적인 state 데이터 혹은 변수를 선언
}
...
```

1. statice getDerivedStateFromProp(props, state) 함수

- 정적 함수
- 함수 안에서 this.props나 this.state와 같은 방법으로 프로퍼티나 state값에 접근할 수 없음
  - 접근 시에는 반드시 인자로 전달된 props, state를 이용해야 함
  - props는 상위 컴포넌트에서 전달된 값
  - state는 현재 컴포넌트의 state 값 (상위 컴포넌트에서 전달받은 프로퍼티. state 값을 연동할 때 주로 사용, 반환값으로 state 변경)

1. render() 함수

- 데이터가 변경되어 새 화면을 그려야 할 때 자동으로 호출되는 함수
- 반환하는 JSX를 화면에 그려줌

1. componentDidMount() 함수

- render() 함수가 JSX를 화면에 그린 이후에 호출되는 함수
- 컴포넌트가 모두 화면에 표현된 이후 해야하는 작업은 여기에서 함

**컴포넌트 갱신 과정**
: 생성 완료 ~ 갱신 완료

1. shouldComponentUpdate(nextProps, nextState) 함수

a. 반환값 true 일 때 이후 과정 진행

b. false인 경우 이후 과정 모두 생략(갱신 과정 생략)

- 프로퍼티를 변경하거나 setState() 함수를 호출하여 state값을 변경하면 **‘화면을 새로 출력해야 하는지' 판단**
- **데이터 변화를 비교하는 작업을 포함하므로 리액트 성능에 영향을 많이 줌**
- 화면 변경을 위해 검증 작업을 하는 경우 사용하면 됨

1. getSnapshotBeforeUpdate(prevProps, prevState) 함수

- 컴포넌트의 변경된 내용이 가상 화면에 완성된 이후 호출되는 함수
- 컴포넌트가 화면에 실제로 출력되기 전에 호출되므로 화면에 출력될 엘리먼트의 크기 또는 스크롤 위치 등 **DOM 정보에 접근할 때 사용**

1. componentDidUpdate(prevProps, prevState, snapshot) 함수

- 컴포넌트가 실제 화면에 출력된 이후 호출되는 함수
- 부모 컴포넌트로부터 전달된 이전 프로퍼티(prevProps)와 이전 state값(prevState)과 함께 getSnapshotBeforeUpdate() 함수에서 반환된 값(snapshot)을 인자로 전달 받음
- 스크롤 위치를 옮기거나 커서를 이동시키는 등 **DOM 정보를 변경할 때 사용**

**컴포넌트 소멸 과정**
: 갱신 완료 ~ 소멸 완료

1. componentWillUnmount() 함수

- 컴포넌트가 소멸되기 직전에 호출되는 함수
- 컴포넌트에서 감시하고 있는 작업들을 해제할 때 필요함
  - 예시 : 컴포넌트에서 setInterval() 함수가 사용되었다면 이 함수에서 clearInterval() 함수로 해제해야 함 → 생략 시 메모리 누수 현상이 발생하여 웹 브라우저의 작동이 멈추기도 함

### 생명주기 함수의 실행 과정 살펴보기

A. **생성 과정의 생명주기 함수들 실행**

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

ReactDOM.render(<App />, document.getElementById('root'));
...
registerServiceWorker();
```

index.js 파일의 ReactDOM.render() 함수가 실행되면 App 컴포넌트의 최초 생명주기 함수인 constructor()가 실행됨

이 때 App 컴포넌트는 자식 컴포넌트를 가지고 있으며, 자식 컴포넌트 역시 독립적인 생명주기를 가짐

```jsx
import React from "react";

class LifecycleExample extends React.Component {
  static getDerivedStateFromProps() {
    console.log("getDerivedStateFromProps 호출");
    return {};
  }
  constructor(props) {
    super(props);
    // getDerivedStateFromProps() 함수를 사용하므로 경고 메시지 건너 뛰기 위해 state 초깃값 설정
    this.state = {};
    console.log("constructor 호출");
  }
  componentDidMount() {
    console.log("componentDidMount 호출");
  }
  componentDidUpdate() {
    console.log("componentDidUpdate 호출");
  }
  componentWillUnmount() {
    console.log("componentWillUnmout 호출");
  }
  getSnapshotBeforeUpdate() {
    console.log("getSnapshotBeforeUpdate 호출");
    return {};
  }
  shouldComponentUpdate() {
    console.log("shouldComponentUpdate 호출");
    return true;
  }

  render() {
    console.log("render 호출");
    return null;
  }
}

export default LifecycleExample;
```

```jsx
import React from "react";
import LifecycleExample from "./03/LifecycleExample";

class App extends React.Component {
  render() {
    return (
      <div>
        <LifecycleExample />
      </div>
    );
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd19f79a-1083-42f4-97dd-250bb88c4373/Untitled.png)

> 생성 생명주기 실행 과정
>
> ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8597f53b-bf76-43ec-a3f5-a41966d14b89/Untitled.png)

B. **변경 과정의 생명주기 함수들**

상위 컴포넌트의 프로퍼티나 state의 변화가 생기면 실행됨

🔽 LifecycleExample 컴포넌트의 componentDidMount() 함수에 setState() 함수를 사용하여 state값 변경

```jsx
componentDidUpdate() {
    console.log("componentDidUpdate 호출");
    // setState()를 사용하여 state값 변경
    this.setState( { updated: true });
}
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/13ebe7de-3113-4de6-adda-3397c3bbd996/Untitled.png)

🔽 shouldComponentUpdate() 함수의 반환값이 false일 때

```jsx
shouldComponentUpdate() {
    console.log("shouldComponentUpdate 호출");
    // return 반환값 강제로 false
    return false;
}
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8409348-e45b-4a10-bb90-ebf2d3980336/Untitled.png)

→ 리액트 엔진은 데이터 비교 후 변경 사항이 없다고 판단하므로 이후 변경 과정의 생명주기 함수가 실행되지 않음

> 변경 생명주기 실행 과정
>
> ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bb2cbc3f-e22f-4021-b8e5-3e939f4255ff/Untitled.png)

shouldComponentUpdate() 함수의 결괏값과 상관없이 화면 동기화 과정을 진행하고 싶다면 forceUpdate() 함수를 사용해야 함

shouldComponentUpdate() 함수의 반환값을 false, LifecycleExample 컴포넌트의 componentDidMount() 함수에 작성했던 setState() 함수를 forceUpdate()로 변경

```jsx
componentDidMount() {
    console.log("componentDidMount 호출");
    // shouldComponent() 함수 결괏값 상관없이 화면 동기화
    this.forceUpdate();
}
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a9eb3453-57f9-4026-9f2e-41bba5019054/Untitled.png)

→ shouldComponentUpdate() 함수의 반환값은 false이지만 **변경 과정의 생명주기 함수가 모두 실행됨**

C. **소멸 과정의 생명주기 함수들 실행**

소멸 과정은 컴포넌트가 화면에서 생략되면 시작됨

소멸 과정 생명주기 함수 실행을 위해 App 컴포넌트를 수정

```jsx
import React from "react";
import LifecycleExample from "./03/LifecycleExample";

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasDestryoed: false };
  }
  componentDidMount() {
    this.setState({ hasDestryoed: true });
  }
  render() {
    return (
      <div>
        <div>{this.state.hasDestryoed ? null : <LifecycleExample />}</div>
      </div>
    );
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60faaee7-beef-4658-beb2-53c8233abaf8/Untitled.png)

> 소멸 생명주기 실행 과정
>
> ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c701becf-661d-4342-a490-594161d1db63/Untitled.png)

### 카운터 프로그램 만들며 생명주기 함수 사용해 보기

부모 컴포넌트로부터 count의 초깃값을 전달받아 숫자를 증가하는 카운터 프로그램

getDerivedStateFromProps() 함수의 동작 원리 학습을 위해 2개의 컴포넌트를 만들어 state 저장 값 변경 실습

1. **Counter 컴포넌트 작성하기**

```jsx
import React from "react";

class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      // count 초깃값을 프로퍼티에서 전달된 값을 설정
      count: props.count,
    };
    this.increaseCount = this.increaseCount.bind(this);
  }
  increaseCount() {
    this.setState(({ count }) => ({
      count: count + 1,
    }));
  }
  render() {
    return (
      <div>
        현재 카운트: {this.state.count}
        <button onClick={this.increaseCount}>카운트 증가</button>
      </div>
    );
  }
}

export default Counter;
```

1. **NewCounter 컴포넌트 작성**

```jsx
import React from "react";

class NewCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {};
    this.increaseCount = this.increaseCount.bind(this);
  }

  static getDerivedStateFromProps(props, state) {
    const { count } = props;
    return {
      // 프로퍼티에서 전달된 count값을 보관
      count,
      newCount:
        count === state.count
          ? // 프로퍼티가 변경되지 않았다면 기존 state값으로 설정
            state.newCount
          : // 프로퍼티가 변경되었다면 변경된 프로퍼티값으로 설정
            count,
    };
  }
  increaseCount() {
    this.setState(({ newCount }) => ({
      newCount: newCount + 1,
    }));
  }
  render() {
    return (
      <div>
        현재 카운트: {this.state.newCount}
        <button onClick={this.increaseCount}>카운트 증가</button>
      </div>
    );
  }
}

export default NewCounter;
```

App 컴포넌트가 전달한 최초의 프로퍼티값은 state.count에 저장됨

NewCounter 컴포넌트는 state.newCount로 증가값을 따로 분리하여 관리

state.count가 아니라 state.newCount로 증가값을 관리하는 이유 : getDerivedStateFromProps() 함수는 다른 프로퍼티가 변경되어도 호출되기 때문

count 프로퍼티가 변경되었는지 비교하려면 값을 따로 관리해야 함

1. **App 컴포넌트에 각 컴포넌트 출력해 보기**

```jsx
import React from "react";
import Counter from "./03/Counter";
import NewCounter from "./03/NewCounter";

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 10 };
    this.resetCount = this.resetCount.bind(this);
  }
  resetCount() {
    this.setState(({ count }) => ({ count: count + 10 }));
  }
  render() {
    return (
      <div>
        <div>
          <Counter count={this.state.count} />
        </div>
        <div>
          <NewCounter count={this.state.count} />
        </div>
        <button onClick={this.resetCount}>
          {this.state.count + 10}으로 초기화
        </button>
      </div>
    );
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f62d7024-ceba-4298-8dd8-3b0a68762f89/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/618a53ab-ad0d-4a47-8d93-2e00dd838aef/Untitled.png)

[카운트 증가] 버튼을 누르면 +1 으로 작동

[20으로 초기화] 버튼을 누르면 Counter 컴포넌트의 숫자는 20으로 초기화 되지 않음

⇒ NewCounter 컴포넌트만 getDerivedStateFromProps() 함수로 App 컴포넌트로부터 갱신된 프로퍼티값을 동기화했기 때문

Counter 컴포넌트는 처음 생성될 때만 프로퍼티값으로 state값을 설정해 갱신 과정에서는 state값이 변경되지 않음.

# 리액트 컴포넌트2

## 3-6. 클래스형 컴포넌트

### Component

- 프로퍼티, state와 생명주기 함수가 들어있는 구조의 컴포넌트를 만들 때 사용
- 항상 render() 함수를 호출

```jsx
import React from 'react';
class MyComponent extends React.Component {
	constructor(props) {
		super(props);
		console.log('생성 함수');
	}
	componentDidMount() { //상속받은 생명주기 함수}
	myMethod() { //추가 확장 함수 }
	render() { //상속받은 화면 출력 함수 }
}
export default MyComponent;
```

### PureComponent

- Component 클래스를 상속받은 클래스
- shouldComponentUpdate() 함수를 ‘얕은 비교' 하도록 재정의
- PureComponent 클래스로 만들어진 컴포넌트는 ‘얕은 비교를 통해 데이터가 변경된 경우'에만 render() 함수를 호출

```jsx
import React from "react";
import shallowEqual from "shallow-equal";

export class PureComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    return (
      !shallowEqual(this.props, nextProps) ||
      !shallowEqual(this.state, nextState)
    );
  }
}
```

→ shallowEqual() 함수로 현재 프로퍼티, state를 갱신한 프로퍼티, state와 얕은 비교를 함

A. 검증 비교를 위한 얕은 비교 알아보기

a. yarn add shallow-equal : shallowEqual 라이브러리 설치

b. 변수 선언

```jsx
import shallowEqual from "shallow-equal";

const obj = { name: "park" };
const mylist = [1, 2, 3, obj];
const list1 = [1, 2, 3, obj];
const list2 = [1, 2, 3, { name: "park" }];

// 1. 깊은 비교를 하는 ===
// : 같은 요소를 가지고 있지만 각각 새롭게 정의된 배열이므로 false
mylist === list1; // false

// 2. 얕은 비교를 하는 shallowEqual() 함수
// : 배열 요소를 일일이 모두 비교할 수 없으므로 얕은 비교
shallowEqual(mylist, list1); // true

shallowEqual(list1, list2); // false, obj와 같은 내용이지만 새 객체이므로
```

내용물을 모두 비교하지 않는 이유 : 비교 검사 작업이 성능에 영향을 끼치기 때문

B. PureComponent와 불변 변수로 성능을 높임

성능을 높이는 방법

- 얕은 비교를 사용하는 PureComponent로 컴포넌트 만들기
- 불변 변수 사용(앱 성능 최대화 목적) → 새 배열을 할당하는 방식으로 비교 속도를 최적화

## 3-7. 함수형 컴포넌트

= state가 없는 함수형 컴포넌트(Stateless Functional Component)

### 함수형 컴포넌트의 구조 알아보기

구조

데이터(프로퍼티, 컨텍스트) → [ 함수 컴포넌트 ] → 출력할 컴포넌트(JSX)

```jsx
import React from "react";
import PropTypes from "prop-types";

function SFC(props, context) {
  // 클래스형 컴포넌트의 this.props값과 동일
  const { somePropValue } = props;
  // 클래스형 컴포넌트의 this.context와 동일
  // (추후 6장에서 학습)
  const { someContextValue } = context;
  return <h1>Hello, {somePropValue}</h1>;
}

SFC.PropTypes = { somePropValue: PropTypes.any };
SFC.defaultProps = { somePropValue: "default value" };

export default SFC;
```

함수형 컴포넌트의 특징

- 클래스 선언이 없음
- 상위 컴포넌트로부터 전달받은 프로퍼티와 컨텍스트만을 이용하여 화면 구성
- state와 생명주기 함수를 사용할 수 없음
- 단순한 구조의 UI 컴포넌트 제작할 때 주로 사용됨

함수형 컴포넌트 사용해보기

```jsx
class TodaysPlanApp extends React.Component {
    **render() {
        const { onButtonClick, hasPlan } = this.props;**
        return (
            <div className="body">
                {hasPlan ? <TodaysPlan /> : null }
                <button onClick={onButtonClick}>
                    계획없음
                </button>

            </div>
        );
    }
}
```

```jsx
// 함수형 컴포넌트로 작성
function TodaysPlanApp(props) {
  const { onButtonClick, hasPlan } = props;
  return (
    <div className="body">
      {hasPlan ? <TodaysPlan /> : null}
      <button onClick={onButtonClick}>계획없음</button>
    </div>
  );
}
```

## 03-8. 배열 컴포넌트

자바스크립트는 다양한 자료형 저장할 수 있고,

이와 같은 성질을 이용하면 XML, JSX도 배열에 저장할 수 있음

```jsx
// JSX 배열
const componentList = [<MyComponent />, <MySecondComponent />, <b>Hi</b>];
```

## 03-8. 배열 컴포넌트

자바스크립트는 다양한 자료형 저장할 수 있고,

이와 같은 성질을 이용하면 XML, JSX도 배열에 저장할 수 있음

```jsx
// JSX 배열
const componentList = [<MyComponent />, <MySecondComponent />, <b>Hi</b>];
```

### 배열 컴포넌트를 위한 map() 함수 사용 방법

- todoList에 저장된 객체를 map() 함수를 통해 JSX로 변경한 것

```jsx
const todoList = [
	{ taskName: '빨래하기', finished: false },
	{ taskName: '공부하기', finished: true },
];
const todos = todoList.map(todo => <div>{todo.taskName}</div>;

// 결과
// [<div>빨래하기</div>,<div>공부하기</div>]
```

- 컴포넌트 형태의 JSX로 변경 가능

```jsx
const todos = todoList.map((todo) => <TodoTask />);
// 결과
// [<TodoTask />, <TodoTask />]
```

- 배열 데이터를 컴포넌트의 프로퍼티에 전달 가능

```jsx
const todoList = [
  { taskName: "빨래하기", finished: false },
  { taskName: "공부하기", finished: true },
];
const todos = todoList.map((todo) => <TodoTask taskName={todo.taskName} />);

// 결과
// [<TodoTask taskName="빨래하기" />, <ㅅTodoTask taskName="공부하기" />]
```

- map() 함수를 이용한 가격표 목록 출력 예제

```jsx
import React from "react";

class ListExample extends react.PureComponent {
  render() {
    const priceList = [1000, 2000, 3000, 4000];
    const prices = priceList.map((price) => <div>가격: {price}원</div>);
    return (
      <div>
        <label>가격 목록</label>
        {prices}
      </div>
    );
  }
}

export default ListExample;
```

App 컴포넌트에 ListExample 컴포넌트 포함시켜 확인

```jsx
import React from "react";
import ListExample from "./03/ListExample";

class App extends React.Component {
  render() {
    return (
      <div>
        <ListExample />
      </div>
    );
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a20591f8-c415-4a10-9a0c-7db6c4886f5e/Untitled.png)

### map() 함수 사용하여 배열 컴포넌트 출력하기

render() 함수에서 바로 map() 함수를 이용해 배열을 출력하는 방법

- 기존 방법으로 배열에 저장된 컴포넌트 출력하는 예제

```jsx
...
render() {
		const todoList = [
				{ taskName: '빨래하기', finished: false },
				{ taskName: '공부하기', finished: true },
		];
    return (
      <div>
        <div>{todo[0].taskName}</div>
        <div>{todo[1].taskName)</div>
      </div>
    );
}
...
```

- map() 함수를 이용하여 코드 수정

```jsx
...
render() {
		const todoList = [
				{ taskName: '빨래하기', finished: false },
				{ taskName: '공부하기', finished: true },
		];
		**const todos = todoList.map(todo => <div>{todo.taskName}</div>);**
    return (
      <div>
			    **{todos}**
      </div>
    );
}
...
```

- map() 함수의 변환된 배열을 반환하는 특징을 이용하여 코드 간략화

```jsx
...
render() {
		const todoList = [
				{ taskName: '빨래하기', finished: false },
				{ taskName: '공부하기', finished: true },
		];
    return (
      <div>
			    **{todoList.map(todo => <div>{todo.taskName}</div>)}**
      </div>
    );
}
...
```

> 배열 컴포넌트는 배열 요소의 개수만큼 반복하므로 성능에 영향을 줌
>
> ⇒ **배열 컴포넌트에는 키값을 key로 꼭 정의해주어야 함**
>
> 키값을 정의하여 출력한 배열 컴포넌트는 다시 출력해야 하는 경우 리액트 엔진이 기존의 컴포넌트를 재활용하여 성능을 높일 수 있기 때문

- 키값을 정의한 배열 컴포넌트의 활용

```jsx
...
render() {
		const todoList = [
				{ taskName: '빨래하기', finished: false },
				{ taskName: '공부하기', finished: true },
		];
    return (
      <div>
			    **{todoList.map((todo, i) => <div key={`tl_${i}`>{todo.taskName}</div>)}**
      </div>
    );
}
...
```

- 인덱스 번호를 키로 사용하면 키값이 함께 변경되는 문제 발생
  (예: filter(...) 함수를 추가하여 finished의 값이 false인 항목을 제외하는 등 항목을 변경하는 경우)

```jsx
{
  todoList
    .filter((todo) => todo.finished)
    .map((todo, i) => <div key={`tl_${i}`}>{todo.taskName}</div>);
}
```

‘공부하기'의 키값은 tl_1 → tl_0으로 바뀌게 되면,
→ 리액트가 컴포넌트 재활용을 하지 못하고 새로 그리게 되어 ‘비효율 문제' 발생
→ 키값으로 고유한 배열 항목을 사용하여 문제 해결

- taskName에 고유값이 들어 있으므로 이를 키값으로 사용하여 이전 키값과 충돌하는 문제 해결

```jsx
import React from "react";

class Todolist extends React.PureComponent {
  render() {
    const todoList = [
      { taskName: "빨래하기", finished: false },
      { taskName: "공부하기", finished: true },
    ];
    return (
      <div>
        {todoList.map((todo) => (
          <div key={todo.taskName}>{todo.taskName}</div>
        ))}
      </div>
    );
  }
}

export default Todolist;
```

App 컴포넌트에 작성 시 브라우저 출력

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/263282ac-7086-49d5-9eef-a04fc427ba0c/Untitled.png)

### render() 함수에서 여러 개의 JSX 노드 반환하기

render() 함수는 트리 구조의 노드를 반환

리액트는 트리 구조의 노드 외에도 배열 구조의 노드를 반환할 수도 있음

- Option 컴포넌트를 3개 반환해야 하는 경우

```jsx
// 잘못 사용된 예
render() {
	return (
		<input type="radio" name="option1" value="1" label="1개" />
		<input type="radio" name="option1" value="2" label="2개" />
		<input type="radio" name="option1" value="3" label="3개" />
	);
}
...
```

render() 함수가 트리 구조의 노드를 반환해야 하므로 위 코드는 동작하지 않음.

- 리액트 16.3 버전 이전 : 트리 구조 노드 1개만 반환 가능하고 여러 개 노드를 반환하고 싶은 경우 의미 없는 최상위 노드를 추가해야함

```jsx
// 최상위 노드 div 엘리먼트를 추가
render() {
	return (
			**<div>**
				<input type="radio" name="option1" value="1" label="1개" />
				<input type="radio" name="option1" value="2" label="2개" />
				<input type="radio" name="option1" value="3" label="3개" />
			**</div>**
	);
}
...
```

- 리액트 16.3 버전 이후 : 의미 없는 노드를 추가하는 것이 개선됨. React.Fragment 컴포넌트가 추가됨

```jsx
render() {
	return (
			**<React.Fragment>**
				<input type="radio" name="option1" value="1" label="1개" />
				<input type="radio" name="option1" value="2" label="2개" />
				<input type="radio" name="option1" value="3" label="3개" />
			**</React.Fragment>**
	);
}
...
```

- React.Fragment의 다른 표현법

```jsx
render() {
	return (
			**<>**
				<input type="radio" name="option1" value="1" label="1개" />
				<input type="radio" name="option1" value="2" label="2개" />
				<input type="radio" name="option1" value="3" label="3개" />
			**</>**
	);
}
...
```

- map() 함수를 사용하면 감싸는 것도 생략 가능

```jsx
render(){
	return [1, 2, 3].map((num) => (
			<input type="radio" name="option1" key={`${num}`} value={num} label={`${num}개`} />
	));
}
```

## 3-9. 컴포넌트에서 콜백 함수와 이벤트 처리하기

> 하위 컴포넌트에서 프로퍼티를 변경해야 할 때는
>
> 프로퍼티 원본을 수정할 수 있는 함수를 하위 컴포넌트에 제공
>
> ⇒ 콜백 함수를 프로퍼티로 전달

<aside>
💡 **콜백 함수**

정의된 위치에서 실행되지 않고

이벤트, 다른 함수 호출 등 특정 상황에서 실행되는 함수

</aside>

### 콜백 함수로 프로퍼티 수정해 보기

Counter 컴포넌트 재활용

- App 컴포넌트에 count값을 증가시킬 목적으로 IncreateCount() 함수를 추가하여 Counter 컴포넌트를 출력

```jsx
import React from 'react';
import Counter from './03/Counter2';

class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            count: 1,
        };
    }
    **increaseCount() {
        this.setState(({ count }) => ({ count: count + 1 }));
    }**
    render() {
        return (
            <Counter count={this.state.count} />
        );
    }
}

export default App;
```

App 컴포넌트에서 state로 관리하는 count값을 변경할 수 있지만 Counter 컴포넌트에서는 변경할 수 없는 상태이므로,

increaseCount() 함수를 프로퍼티 형태로 전달하여 count값을 변경할 수 있도록 수정

- App 컴포넌트에서 Counter 컴포넌트의 프로퍼티로 onAdd 추가

```jsx
import React from "react";
import CounterApp from "./03/CounterApp";

class CounterApp extends React.Component {
  render() {
    return <Counter count={this.state.count} onAdd={this.increaseCount} />;
  }
}

export default App;
```

- 하위 컴포넌트 Counter2 작성

```jsx
import React from "react";
import PropTypes from "prop-types";

class Counter2 extends React.Component {
  render() {
    return (
      <div>
        현재 카운트: {this.props.count}
        <button onClick={() => this.props.onAdd()}>카운트 증가</button>
      </div>
    );
  }
}

Counter2.PropTypes = {
  count: PropTypes.number,
  onAdd: PropTypes.func,
};

export default Counter2;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/938d3186-b466-43bf-9337-34bc55dfeb46/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/292adc7f-709c-49c7-9741-369a00f3134e/Untitled.png)

카운트 증가 버튼을 눌러도 실행되지 않고, 콘솔 Uncaught TypeError: this.setState is not a function 오류 발생

: Counter2 컴포넌트에서 프로퍼티로 받아 실행한 onAdd() 함수에서 참조하는 this의 범위 때문에 발생한 오류

onAdd() 함수에 구현되어 있는 this.setState(...)는 상위 컴포넌트(App)에 정의되어 있는데 하위 컴포넌트(Counter2)에서 실행되기 때문

<aside>
💡 콜백 함수를 프로퍼티 데이터로 전달하는 경우에는 하위 컴포넌트에서 참조할 this 범위에 대한 오류를 주의해야 함

</aside>

### bind() 함수로 this 범위 오류 해결하기

- App 컴포넌트 수정

```jsx
render() {
    return <Counter count={this.state.count} **onAdd={this.increaseCount.bind(this)}** />;
}
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/515364e1-412b-4ceb-b20a-d1c667627f62/Untitled.png)

increateCount() 함수가 호출되는 this 범위가 App 컴포넌트에 묶여 button이 제대로 동작함

bind() 함수는 constructor() 함수에 모아두면 매번 render() 함수를 호출할 때마다 새로 작성하지 않아도 됨

- App 컴포넌트 수정 ver2

```jsx
import React from "react";
import Counter from "./03/Counter2";

class App extends React.Component {
  constructor(props) {
    super(props);
    **// B. bind() 함수로 범위 수정(2)
    this.increaseCount = this.increaseCount.bind(this);**
  }
  increaseCount() {
    this.setState(({ count }) => ({ count: count + 1 }));
  }
  render() {
    return (
      **// B. bind() 함수로 범위 수정(2)
      <Counter count={this.state.count} onAdd={this.increaseCount} />**
    );
  }
}

export default App;
```

교재 함수명이 increaseCount가 increateCount로 오타난 것 같은데 반영해도 에러 발생...... ?????? 모르겠다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c39a85f-803b-4333-a6bb-2d5fd620942e/Untitled.png)

해결

예제 코드에서 this.state = { count:1, }; 이 누락되어 있었음

```jsx
import React from "react";
import Counter from "./03/Counter2";

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 1,
    };
    **this.increaesCount = this.increaseCount.bind(this);**
  }
  increaseCount() {
    this.setState(({ count }) => ({ count: count + 1 }));
  }
  render() {
    return <Counter count={this.state.count} onAdd={this.increaseCount} />;
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/48f800db-eace-479c-b291-ff47605c74ad/Untitled.png)

### 컴포넌트에서 DOM 객체 함수 사용하기

<aside>
💡 **특수 프로퍼티 ref**

컴포넌트 window.addEventListner와 같은 DOM 객체 함수 사용 시 DOM 객체를 컴포넌트 변수에 할당하는 역할

document.getEelementById()가 반환하는 객체를 반환

DOM 객체 함수가 필요한 엘리먼트에 콜백 함수 형태로 전달됨

</aside>

- 화면에서 스크롤 위치를 측정해 현재 컴포넌트의 위치가 화면 안에 있는지 알려주는 컴포넌트 작성

```jsx
import React from 'react';

export default class ScrollSpy extends React.PureComponent {
    constructor(props) {
        super(props);
        this.setRef = this.setRef.bind(this);
        this.checkPosition = this.checkPosition.bind(this);
        // 1. 윈도우의 스크롤 이동 이벤트를 감지하여 checkPosition() 함수가 실행되도록 함
        window.addEventListener('scroll', this.checkPosition);
    }
    setRef(ref) {
        // 2. ref 프로퍼티에서 반환된 객체를 컴포넌트 변수에 할당
        this.ref = ref;
    }
    checkPosition() {
        if (this.ref.getBoundingClientRect().top < window.innerHeight) {
            // 3. 현재 DOM 객체의 위치가 스크롤 화면 안팎인지 측정
            console.log(('enter'));
        }else{
            console.log('exit');
        }
    }
    componentDidMount() {
        this.checkPosition();
    }
    componentWillUnmount() {
        // 4. 컴포넌트가 소멸할 때 화면 스크롤 감시 함수를 메모리에서 제거
        window.removeEventListener('scroll', this.checkPosition);
    }
    render() {
        return (
            <div ref={this.setRef} />
        );
    }
}

export default ScrollSpy;
```

사용 예시

페이스북에서 스크롤을 내릴 때 자동으로 다음 페이지 목록을 추가할 때

console.log(’enter’)에 다음 페이지 목록을 추가하는 코드를 구현하면 됨

### 컴포넌트에서 DOM 이벤트 사용하기

컴포넌트에서 출력된 특정 DOM 객체에 이벤트 컴포넌트가 반응하기 위해서 DOM 이벤트 프로퍼티 사용/

ex. 컴포넌트에 출력된 버튼이 클릭되었을 때 카운트 숫자가 증가하는 경우

이벤트 프로퍼티는 특수 프로퍼티로 콜백 함수 형태로 전달해 처리

- 자주 쓰는 이벤트 이름과 DOM 이벤트 프로퍼티

| 이벤트 이름 | 이벤트 호출 시점                                  | JSX DOM 이벤트 프로퍼티 |
| ----------- | ------------------------------------------------- | ----------------------- |
| click       | 엘리먼트의 마우스나 키보드가 클릭될 때            | onClick                 |
| submit      | 폼의 데이터가 전송될 때                           | onSubmit                |
| mousemove   | 엘리먼트 위에서 마우스 커서가 움직일 때           | onMouseMove             |
| mouseover   | 엘리먼트 영역 위로 마우스 커서가 돌아다닐 때      | onMouseOver             |
| mouseout    | 엘리먼트 위에 있던 마우스 커서가 영역을 떠나갈 때 | onMouseOut              |
| keydown     | 키보드 버튼이 눌렸을 때                           | onKeyDown               |
| keypress    | 키보드 버튼 입력이 완료되었을 때                  | onKeyPress              |

- 맵핑된 프로퍼티는 아래와 같이 콜백 함수 형태로 이벤트를 처리할 수 있음

```jsx
import React from "react";

class Counter3 extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
    this.increaseCount = this.increaseCount.bind(this);
    this.resetCount = this.resetCount.bind(this);
  }
  increaseCount() {
    this.setState((count) => ({ count: count + 1 }));
  }
  resetCount() {
    this.setState({ count: 0 });
  }
  render() {
    return (
      <div>
        현재 카운트: {this.state.count}
        <button
          // 1. 버튼이 클릭될 때 카운트를 증가하는 함수 호출
          onClick={this.increaseCount}
          // 2. 버튼 밖으로 마우스가 이동하면 카운트를 초기화하는 함수를 호출
          onMouseOut={this.resetCount}
        >
          카운트 증가
        </button>
        버튼 밖으로 커서가 움직이면 0으로 초기화됩니다.
      </div>
    );
  }
}

export default Counter3;
```

### 단방향 흐름 방식 개념 정리

리액트는 프로퍼티, state와 같은 데이터를 상위 컴포넌트에서 하우 ㅣ컴포넌트로 전달

데이터 변경이 필요한 경우 콜백 함수를 호출하여 우너본 데이터가 위치한 상위 컴포넌트에서 데이터를 변경하고 다시 자식 컴포넌트로 전달하도록 만듦

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/338f6a73-1b12-488f-9775-edd3d52f0ea5/Untitled.png)

## 3-10. Input 컴포넌트 만들면서 복습하기

```jsx
import React, { PureComponent } from "react";
import PropTypes from "prop-types";

class Input extends PureComponent {
  // 1. 클래스형 컴포넌트의 PureComponent 형태로 작성
  constructor(props) {
    super(props);
    this.setRef = this.setRef.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }
  handleChage(e) {
    const { name, onChange } = this.props;
    if (onChange) {
      onChange(name, e.target.value);
    }
  }
  componentDidMount() {
    // 2. autoFocus값이 true일 경우 출력 후 input 박스에 자동으로 커서를 배치
    if (this.props.autoFocus) {
      this.ref.focus();
    }
  }
  componentDidUpdate() {
    // 3. autoFocus값이 true일 경우 출력 후 input 박스에 자동으로 커서를 배치
    if (this.props.autoFocus) {
      this.ref.focus();
    }
  }
  setRef(ref) {
    this.ref = ref;
  }
  render() {
    const { errorMessage, label, name, value, type, onFocus } = this.props;
    return (
      <label>
        {/* 4. label 안에 전달받은 label값을 출력 */}
        {label}
        <input
          id={`input_${name}`}
          ref={this.setRef}
          // 5. input 값이 변경될 때 onChange 콜백 함수를 호출
          onChange={this.handleChange}
          // 6. 프로퍼티로 전달받은 콜백 함수를 DOM 이벤트 프로퍼티에 연결하여 input에 마우스 커서가 포커스될 때 상위 컴포넌트의 콜백 함수를 호출
          onFocus={onFocus}
          value={value}
          type={type}
        />
        {/* 7. errorMessage가 존재할 경우 출력 */}
        {errorMessage && <span className="error">{errorMessage}</span>}
      </label>
    );
  }
}

Input.propTypes = {
  // 8. 문자열형의 값 'text', 'number', 'price' 중 하나의 값만 가질 수 있음
  type: PropTypes.oneOf(["text", "number", "price"]),
  name: PropTypes.string.isRequired,
  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  errorMessage: PropTypes.string,
  label: PropTypes.string,
  onChange: PropTypes.func,
  onFocus: PropTypes.func,
  autoFocus: PropTypes.bool,
};
Input.defaultProps = {
  onChage: () => {},
  onFocus: () => {},
  autoFocus: false,
  // 9. type의 기본값은 'text'
  type: "text",
};
export default Input;
```
