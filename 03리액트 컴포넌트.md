# 3. 리액트 컴포넌트

## 3-1. 컴포넌트를 표현하는 JSX

<aside>
✅ **JSX(JavaScript XML)**

- 자바스크립트에 XML을 추가한 확장형 문법
- 하나의 파일에 자바스크립트와 HTML을 동시에 작성할 수 있어 편리함
</aside>

### JSX 사용해보기

```jsx
import React from 'react';

class App extends React.Component{
    render() {
        return (
            // JSX 양식
            <div>
                <img src="http://www.easypub.co.kr/images/logo_footer.png" />
                <div>안녕하세요</div>
            </div>
        );
    }
}
export defalut App;
```

위 코드의 JSX

- return() 함수 내에 HTML을 사용
- img 엘리먼트에 />에 사용

render() 함수의 반환값은 거의 HTML과 비슷하지만 마침 표시 />가 있다는 차이가 있음

⇒ JSX는 XML 마크업 규칙을 따름 ( <와 /> 짝이 맞지 않으면 리액트 엔진이 JSX 분석 시 오류 발생)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc3e8fc3-8b7b-4122-9f0c-ee0d11b2efbb/Untitled.png)

- creat-react-app은 오류 발생 시 웹 브라우저에서 바로 볼 수 있음
  ![syntax error](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2b460183-25bb-44d3-9a2e-b2f4ec35f342/Untitled.png)
  syntax error
- 오류 해결하면 정상적으로 브라우저에서 확인 가능
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef771799-e658-4160-b732-cc7faf9a09b3/Untitled.png)

### JSX와 기존 개발 방법의 차이점

1. App 컴포넌트를 사용하지 않고 화면 구성해 보기

index.js - npm start(yarn start) 명령어로 리액트 서버 구동 시 최초로 실행됨

```jsx
// 필수 리액트 구동 모듈들
import React from "react";
import ReactDOM from "react-dom/client";
// 초기 화면을 구성하는 사용자 코드
import "./index.css";
import App from "./App";
import * as serviceWorker from "./serviceWorker";

// 리액트 엔진이 화면을 출력하는 코드
// id가 root인 엘리먼트에 컴포넌트를 출력
ReactDOM.render(<App />, document.getElementById("root"));

// 서비스 워커 구동 코드로 오프라인 모드로 작동하는 데 도움이 되는 모듈
// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
serviceWorker.unregister();
```

1. App 컴포넌트 미사용 시 코드 수정

```jsx
var img = document.createElement("img");
img.setAttribute("src", "http://www.easyspub.co.kr/images/logo_footer.png");
var divEl = document.createElement("div");
divEl.innerText = "안녕하세요";
var welcomeEl = document.createElement("div");
welcomeEl.append(img);
welcomeEl.append(divEl);

var root = document.getElementById("root");
root.append(welcomeEl);
```

브라우저는 같은 값을 보여 주지만, 코드가 복잡해져 비효율적임

1. 실습에 불필요한 코드까지 정리

```jsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root"));
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31d4a2f0-821b-49b1-b9d4-96ddebb21241/Untitled.png)

### JSX 작동 원리

```jsx
...
return (
  // JSX가 자바스크립트로 변환된 것
  React.createElement(
    "div",
    null,
    React.createElement("img", {
      src: "http://easyspub.co.kr/images/logo_footer.png"
    }),
    React.createElement(
      "div",
      null,
      "안녕하세요"
    )
  )
);
```

리액트 엔진은 JSX의 XML 구조를 분석하여 자바스크립트 함수 코드로 변환

React.createElement() 함수는 리액트 엔진에 포함되어 있고, 기존 자바스크립트의 document.createElement() 함수를 사용하여 객체 모델을 생성함

리액트를 사용하면 이 같은 과정 없이 JSX로 화면을 빠르게 구성할 수 있음 ⇒ “선언형 화면(Declarative View)”

JSX는 개발자가 화면 구성에만 집중할 수 있도록 도움

## 3-2. 컴포넌트와 구성 요소

> **컴포넌트는 리액트의 꽃이라 불릴 정도로 리액트에서 가장 중요한 요소**

### 컴포넌트의 개념

기존의 웹 프레임워크

- MVC 방식 : 정보Model, 화면View, 구동 코드Controller를 분리하여 관리
- 장점 : 코드 관리를 효율적으로 할 수 있음
- 단점 : MVC 각 요소의 의존성이 높아 재활용이 어려움

→ 웹 사이트의 요소가 비슷하고 반복적인 점을 착안하여 컴포넌트가 등장하게 됨

컴포넌트

- MVC의 뷰를 독립적으로 구성하여 재사용 가능
- 컴포넌트를 통해 새로운 컴포넌트를 쉽게 만들 수 있음

### 컴포넌트 추가하고 화면으로 띄워보기

1. TodaysPlan 컴포넌트 만들기
   TodaysPlan.jsx

```jsx
import React from "react";

class TodaysPlan extends React.Component {
  render() {
    return <div className="message-container">놀러가자</div>;
  }
}

export default TodaysPlan;
```

- 컴포넌트 이름의 첫 번째 글자는 반드시 대문자여야 함

1. App 컴포넌트에 TodaysPlan 컴포넌트 추가하기

작성한 컴포넌트 App 컴포넌트에 추가

컴포넌트를 마크업 형식으로 추가하므로 첫 글자가 대문자여야 함!

```jsx
import React from "react";
// 작성된 컴포넌트를 불러들임
import TodaysPlan from "./03/TodaysPlan";

class App extends React.Component {
  render() {
    return (
      <div className="body">
        <TodaysPlan />
      </div>
    );
  }
}
export default App;
```

1. TodaysPlan 컴포넌트 출력하기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d84334cb-466f-4517-9d2c-130b18823aae/Untitled.png)

<aside>
💡 Import문에서 파일 이름 확장자가 생략된 이유

create-react-app은 js / jsx 확장자를 생략해도 해당 파일을 자동으로 찾을 수 있게 설정됨

“웹팩 코드 검색 확장자(webpack module resolution)” 기능

웹팩은 임포트된 파일을 분석하여 하나의 자바스크립트 파일 생성할 때 파일 위치를 검색함(이 때 확장자 기능 참조)

</aside>

### 컴포넌트 구성 요소 미리 살펴보기

데이터 구성요소

- 프로퍼티 : 상위 컴포넌트에서 하위 컴포넌트로 전달되는 읽기 전용 데이터
- state : 컴포넌트의 상태를 저장하고 변경할 수 있는 데이터
- 컨텍스트 : 부모 컴포넌트에서 생성하여 모든 자식 컴포넌트에 전달하는 데이터

## 3-3. 컴포넌트에 데이터를 전달하는 프로퍼티

### 프로퍼티 기초 알아보기

App 컴포넌트에서 프로퍼티를 MyComponent 컴포넌트에 전달한 예제

속성(attribute) 형태로 전달되는 값을 프로퍼티라고 일컫는다

```jsx
class App extends React.Component {
  render() {
    return (
      <div className="body">
        <MyComponent name="message" />
      </div>
    );
  }
}
```

MyComponent 컴포넌트에서는 name 이라는 이름의 프로퍼티로 전달받은 “message”라는 문자열값을 render() 함수에서 참조할 수 있음

render() 함수에서 this.props.name 으로 프로퍼티 값을 참조하고 있음

```jsx
class App extends React.Component {
  render() {
    const name = this.props.name;
    return <span>{name}</span>;
  }
}
```

프로퍼티는 상위 컴포넌트→하위 컴포넌트로 전달됨

App 컴포넌트가 MyComponent를 포함하고 있으며 프로퍼티는 App → MyComponent 방향으로 전달됨 [단방향으로 데이터가 흐른다]

### 프로퍼티의 다양한 사용 방법 알아보기

프로퍼티에서는 자바스크립트의 모든 자료형 사용 가능

자료형은 미리 선언해주는 것이 좋음

- 리액트 엔진이 프로퍼티로 전달하는 값의 변화를 효율적으로 감지
- 지정되지 않은 자료형을 프로퍼티에 전달하려고 할 때 경고 메세지로 알려줌(버그 예방)

1. **문자열형 프로퍼티 사용하기**

: 리액트에서 제공하는 prop-types 이용

```jsx
import React from "react";
// 1. prop-types 라이브러리를 PropTypes라는 이름으로 임포트
import PropTypes from "prop-types";

class PropsComponent extends React.Component {
  render() {
    // 2. name 프로퍼티로 받은 문자열 출력
    return <div className="message-container">{this.props.name}</div>;
  }
}

// 자료형을 선언하는 예제
PropsComponent.propTypes = {
  // 3. PropsComponent의 propTypes라는 특수 변수(prop-types 라이브러리 임포트 이름과 다름)를 사용하여 프로퍼티의 자료형 정의
  // 4. 프로퍼티의 자료형을 객체 형태로 지정하여 PropsComponent.propTypes에 저장
  name: PropTypes.string,
};

export default PropsComponent;
```

```jsx
import React from "react";
import PropsComponent from "./03/PropsComponent";

class App extends React.Component {
  render() {
    return <PropComponent name="두잇 리액트" />;
  }
}
export default App;
```

```jsx
import React from "react";
import PropComponent from "./03/propsComponent";

class App extends React.Component {
  render() {
    return <PropComponent name="두잇 리액트" />;
  }
}
export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/04bca4ac-0ef8-42f9-aa71-9e0c2be10a88/Untitled.png)

PropComponent 컴포넌트의 프로퍼티로 전달한 문자열이 출력됨

1. **다양한 프로퍼티 사용하기**

문자열 전달 : “ “ 사용

숫자형/불리언 전달 : 큰따옴표 사용 불가

문자열 이외의 값은 중괄호{} 사용

```jsx
import React from "react";
import PropTypes from "prop-types";

class ChildComponent extends React.Component {
  render() {
    const {
      // 객체 구조 분해 할당식을 사용하여 프로퍼티에 전달된 값들을 render() 함수 내의 지역 변수로 재 정의
      boolValue,
      numValue,
      arrayValue,
      objValue,
      nodeValue,
      funcValue,
    } = this.props;

    return (
      <div>
        <span>불리언값: {boolValue}</span>
        <span>숫자값: {numValue}</span>
        <span>배열값: {arrayValue}</span>
        <span>객체값: {String(objValue)}</span>
        <span>노드값: {nodeValue}</span>
        <span>함수값: {String(funcValue)}</span>
      </div>
    );
  }
}
ChildComponent.propTypes = {
  // 객체 형태로 프로퍼티의 자료형을 정의
  boolValue: PropTypes.bool,
  numValue: PropTypes.number,
  arrayValue: PropTypes.arrayOf(PropTypes.number),
  objValue: PropTypes.object,
  nodeValue: PropTypes.node,
  funcValue: PropTypes.func,
};

export default ChildComponent;
```

객체 구조 분해 할당식으로 프로퍼티에 전달된 값을 함수 내 지역 변수로 재정의하면,

this.props.boolValue에서 boolValue와 같이 this.props를 제외하는 방법으로 간단하게 프로퍼티에 접근 가능

새로운 컴포넌트를 만들었으니 App 컴포넌트를 수정해 확인함

```jsx
import React from "react";
import ChildComponent from "./03/ChildComponent";

class App extends React.Component {
  render() {
    return (
      // 수정
      <ChildComponent
        //1.불리언값 전달
        boolValue={true}
        //2.숫자 전달
        numValue={1}
        //3.배열 전달
        arrayValue={[1, 2, 3]}
        //4.객체 전달
        objValue={{ name: "제목", age: 30 }}
        //5.노드 전달
        nodeValue={<h1>노드</h1>}
        //6.함수 객체 전달
        funcValue={() => {
          console.log("메시지");
        }}
      />
    );
  }
}

export default App;
```

arrayValue={[1,2,3]} 처럼 두 개의 중괄호를 사용하는 이유는 개발자 간의 실수를 줄이기 위하여 변수를 객체에 담아 전달하는 방식 선호

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/269383ec-4b25-44b4-af09-8a0308a251f5/Untitled.png)

```jsx
import React from "react";
import ChildComponent from "./03/ChildComponent";

class App extends React.Component {
  render() {
    const array = [1, 2, 3];
    const obj = { name: "제목", age: 30 };
    const node = <h1>노드</h1>;
    const func = () => {
      console.log("메시지");
    };
    return (
      // 수정
      <ChildComponent
        //1.불리언값 전달
        boolValue={true}
        //2.숫자 전달
        numValue={1}
        //3.배열 전달
        arrayValue={array}
        //4.객체 전달
        objValue={obj}
        //5.노드 전달
        nodeValue={node}
        //6.함수 객체 전달
        funcValue={func}
      />
    );
  }
}

export default App;
```

배열, 객체, 노드, 함수를 변수에 담아 전달한 것

1. **불리언 프로퍼티 사용하기**

불리언 : true 또는 false만 정의할 수 있는 특수한 자료형

문자열 외 값은 중괄호로 감싸 전달해야 하지만 불리언은 특별한 방법으로도 전달할 수 있음

true

- 프로퍼티 이름 선언 : <ChildComponent boolVaule />

false

- 이름 생략 : <ChildComponent />

```jsx
import React from "react";

class BooleanComponent extends React.Component {
  render() {
    // 불리언 타입을 조건문에 적용한 예제
    const message = this.props.bored
      ? "놀러 가자"
      : "하던 일 열심히 마무리하기";
    return <div className="message-container">{message}</div>;
  }
}

export default BooleanComponent;
```

```jsx
import React from "react";
import BooleanComponent from "./03/BooleanComponent";

class App extends React.Component {
  render() {
    return (
      <div>
        <div>
          <b>지루할 때:</b>
          <BooleanComponent bored />
        </div>
        <div>
          <b>즐거울 때:</b>
          <BooleanComponent />
        </div>
      </div>
    );
  }
}

export default App;
```

![브라우저](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c739a8d8-5821-48ea-b396-ef7aaf7f2b64/Untitled.png)

브라우저

> 프로퍼티의 이름만 전달한 경우 true, 프로퍼티 이름을 전달하지 않은 경우 false에 해당하는 값이 출력됨
> 실무에서 사용되는 빈도가 높음

1. **객체형 프로퍼티 사용하기**

```jsx
import React from "react";
import PropTypes from "prop-types";

class ChildComponent2 extends React.Component {
  render() {
    const { objValue } = this.props;

    return (
      <div>
        <div>객체값: {String(Object.entries(objValue))}</div>
      </div>
    );
  }
}
ChildComponent2.propTypes = {
  // 객체 프로퍼티
  objValue: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number,
  }),
};

export default ChildComponent2;
```

내장함수 String()과 Object.entries()를 사용하여 객체를 문자열로 변환하여 출력

객체 프로퍼티의 자료형은 PropTypes의 shape를 사용하여 정의

PropTypes.shape로 객체 프로퍼티를 정의하면 객체 목록을 한눈에 확인할 수 있어 편리함

1. **필수 프로퍼티 사용하기**

```jsx
import React from "react";
import PropTypes from "prop-types";

class ChildComponent2 extends React.Component {
  render() {
    const { objValue, requiredStringValue } = this.props;

    return (
      <div>
        <div>객체값: {String(Object.entries(objValue))}</div>
        <div>필수값: {requiredStringValue}</div>
      </div>
    );
  }
}
ChildComponent2.propTypes = {
  // 객체 프로퍼티
  objValue: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number,
  }),
  // 필수 프로퍼티
  requiredStringValue: PropTypes.string.isRequired,
};

export default ChildComponent2;
```

PropTypes에 정의된 변수(string, object, bool, ...) 안의 특수 변수 isRequired를 이용하여 requiredStringValue를 필수 프로퍼티로 지정

```jsx
import React from "react";
import ChildComponent2 from "./03/ChildComponent2";

class App extends React.Component {
  render() {
    return (
      <div>
        <ChildComponent2 objValue={{ age: "20살" }} />
      </div>
    );
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0f6b4362-3a4e-4c80-8429-ad7c9b509832/Untitled.png)

콘솔 오류

- age에 문자열을 대입

- 필수 프로퍼티로 지정한 requiredStringValue에 값이 전달되지 않았음

코드 수정

```jsx
import React from "react";
import ChildComponent2 from "./03/ChildComponent2";

class App extends React.Component {
  render() {
    return (
      <div>
        <ChildComponent2 objValue={{ age: 20 }} requiredStringValue="문자" />
      </div>
    );
  }
}

export default App;
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c46ecad-7f0c-4bc3-8a3e-05f96e86dcc1/Untitled.png)

1. **프로퍼티에 기본값 지정하기**

기본값을 저장할 컴포넌트의 defaultProps 값을 이용하면 됨

```jsx
import React from "react";
import PropTypes from "prop-types";

class DefaultPropsComponent extends React.Component {
  render() {
    let message1 = "";
    if (this.props.boolValue === false) {
      message1 = "boolValue 기본값이 false 입니다.";
    }
    let message2 = "";
    if (this.props.boolValueWithoutDefault === false) {
      message2 = "boolValueWithoutDefault 기본값이 false입니다.";
    }
    return (
      <div className="message-container">
        {message1}
        {message2}
      </div>
    );
  }
}

DefaultPropsComponent.propTypes = {
  boolValue: PropTypes.bool,
  boolValueWithoutDefault: PropTypes.bool,
};

// 기본값을 선언하는 예제(특수 변수를 사용하여)
DefaultPropsComponent.defaultProps = {
  boolValue: false,
};

export default DefaultPropsComponent;
```

- 코드
  특수변수를 사용하여 프로퍼티의 기본값을 정의
  불리언 프로퍼티 2개 선언하고 하나의 프로퍼티에만 기본값을 지정
  그다음 두 조건문에서 ===로 비교
  boolValue에만 false가 기본값이라 message1만 출력됨

App 컴포넌트 수정

```jsx
import React from "react";
import DefaultPropsComponent from "./03/DefaultPropsComponent";

class App extends React.Component {
  render() {
    return (
      <div>
        <DefaultPropsComponent />
      </div>
    );
  }
}

export default App;
```

![브라우저](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9115a840-3b6d-47f6-917e-6203183f086b/Untitled.png)

브라우저

1. **자식 프로퍼티 사용하기**

```jsx
<div>
  <button>버튼</button>
</div>
```

위와 같이 중간에 노드를 배치하는 표현식도 JSX에서 표현 가능함

JSX에서는 컴포넌트 하위에 배치한 노드(또는 컴포넌트)를 하위 컴포넌트에서 프로퍼티로 접근할 수 있게 해줌

App 컴포넌트에 포함시킨 ChildProperty 컴포넌트 하위에 자식 노드를 배치한 경우

```jsx
import React from "react";
import ChildProperty from "./03/ChildProperty";

class App extends React.Component {
  render() {
    return (
      <div>
        <ChildProperty>
          <div>
            <span>자식 노드</span>
          </div>
        </ChildProperty>
      </div>
    );
  }
}

export default App;
```

ChildProperty 컴포넌트에서는 {this.props.children}과 같은 방법으로 <div><span>자식 노드</span></div>를 쉽게 받을 수 있음

```jsx
import React, { Component } from "react";
import PropTypes from "prop-types";

class ChildProperty extends Component {
  render() {
    return <div>{this.props.children}</div>;
  }
}
ChildProperty.propTypes = {
  children: PropTypes.node,
};
export default ChildProperty;
```

별도의 프로퍼티를 통해 자식 노드를 전달할 수도 있지만 위 코드가 훨씬 간편함
